package core

import (
	"fmt"

	"bitbucket.org/bdsengineering/perceptor/pkg/clustermanager"
	common "bitbucket.org/bdsengineering/perceptor/pkg/common"
	"bitbucket.org/bdsengineering/perceptor/pkg/scanner"
	"github.com/prometheus/common/log"
)

// VulnerabilityCache is the root model
type VulnerabilityCache struct {
	// TODO add lock here, and lock in every
	// "method" call down below

	// TODO what do we do about pod namespaces?
	pods map[string]Pod
	// TODO does this need to be map[string]*ImageScanResults ?
	imageScanResults map[string]ImageScanResults

	imagesToBeScanned chan common.Image
	imageScanComplete chan ImageScanComplete

	// ?? queue of things waiting to be picked up from hub
	// ?? queue of things waiting to be sent to API server
}

func (vc *VulnerabilityCache) ImagesToBeScanned() <-chan common.Image {
	return vc.imagesToBeScanned
}

func (vc *VulnerabilityCache) ImageScanComplete() <-chan ImageScanComplete {
	return vc.imageScanComplete
}

// What should this be set to?  ... who knows
// This is in place of a queue implementation to keep track
// of the images that need to be scanned by the hub.
// Maybe we can change that later.
// Let's hope 300 is large enough to keep it from blocking,
// but doesn't waste tons of memory.
var pendingImageScanLimit = 300
var pendingImageAnnotationLimit = 300

func NewVulnerabilityCache() *VulnerabilityCache {
	return &VulnerabilityCache{
		pods:              make(map[string]Pod),
		imageScanResults:  make(map[string]ImageScanResults),
		imagesToBeScanned: make(chan common.Image, pendingImageScanLimit),
		imageScanComplete: make(chan ImageScanComplete, pendingImageAnnotationLimit),
	}
}

// AddPod should be called when receiving new pods from the
// clustermanager.  It returns true if it hasn't yet seen the pod,
// and false if the pod has already been added.
// It extract the containers and images from the pod,
// adding them into the cache.
func (vc *VulnerabilityCache) AddPod(newPod clustermanager.Pod) bool {
	_, ok := vc.pods[newPod.Name]
	if ok {
		// TODO should we update the cache?
		// skipping for now
		return false
	}
	log.Info("about to add pod: %v", newPod)
	containers := []Container{}
	for _, newCont := range newPod.Spec.Containers {
		addedCont := NewContainer(newCont.Image, newCont.Name)
		containers = append(containers, *addedCont)
		_, hasImage := vc.imageScanResults[newCont.Image]
		if !hasImage {
			addedImage := NewImageScanResults()
			vc.imageScanResults[newCont.Image] = *addedImage
			log.Infof("adding image %s to cache", newCont.Image)
			vc.imagesToBeScanned <- *common.NewImage(newCont.Image)
		} else {
			log.Infof("not adding image %s, already have in cache", newCont.Image)
		}
	}
	log.Infof("done adding containers+images from pod %s:%s", newPod.Namespace, newPod.Name)
	addedPod := NewPod(newPod.Name, string(newPod.UID), newPod.Namespace, containers)
	// TODO this should probably be using addedPod.UID
	vc.pods[newPod.Name] = *addedPod
	return true
}

func (vc *VulnerabilityCache) AddScanResult(image string, project scanner.Project) error {
	results := ScanResults{}
	if len(project.Versions) == 0 {
		return &ScanResultsError{"expected at least 1 project version, found 0"}
	}
	version := project.Versions[0]
	vulnerabilities, ok := version.RiskProfile.Categories["VULNERABILITY"]
	if !ok {
		// TODO do we also need to look for ACTIVITY, LICENSE, OPERATIONAL, and VERSION ?
		return &ScanResultsError{"expected categories to contain key 'VULNERABILITY'"}
	}
	// TODO do we also need to look for low and medium?
	highCount, ok := vulnerabilities["HIGH"]
	if !ok {
		return &ScanResultsError{"expected vulnerabilities to contain key 'HIGH'"}
	}
	results.VulnerabilityCount = highCount

	results.OverallStatus = version.PolicyStatus.OverallStatus

	violationCount, ok := version.PolicyStatus.ComponentVersionStatusCounts["IN_VIOLATION"]
	if !ok {
		results.PolicyViolationCount = 0
		// TODO return &ScanResultsError{"expected policy status component version status counts to contain 'IN_VIOLATION'"}
	}
	// TODO count IN_VIOLATION_OVERRIDDEN ?
	results.PolicyViolationCount = violationCount

	// add scan results into cache
	img, ok := vc.imageScanResults[image]
	if !ok {
		return &ScanResultsError{fmt.Sprintf("expected to already have image %s, but did not", image)}
	}

	img.ScanResults = &results
	img.ScanStatus = ScanStatusComplete

	affectedPods := []Pod{}
	for _, pod := range vc.pods {
		if pod.hasImage(image) {
			affectedPods = append(affectedPods, pod)
		}
	}
	isc := ImageScanComplete{
		AffectedPods: affectedPods,
		Image:        image,
		ScanResults:  results,
	}
	vc.imageScanComplete <- isc

	return nil
}
