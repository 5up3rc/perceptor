package core

import (
	"errors"
	"fmt"
	"sync"

	"bitbucket.org/bdsengineering/perceptor/pkg/clustermanager"
	common "bitbucket.org/bdsengineering/perceptor/pkg/common"
	"bitbucket.org/bdsengineering/perceptor/pkg/scanner"
	"github.com/prometheus/common/log"
)

// VulnerabilityCache is the root of the core model
type VulnerabilityCache struct {
	mutex sync.Mutex

	// map of pod-uid to pod
	Pods             map[string]Pod
	ImageScanResults map[common.Image]*ImageScanResults

	imagesToBeScanned chan common.Image
}

func (vc *VulnerabilityCache) ImagesToBeScanned() <-chan common.Image {
	return vc.imagesToBeScanned
}

// What should this be set to?  ... who knows
// This is in place of a queue implementation to keep track
// of the images that need to be scanned by the hub.
// Maybe we can change that later.
// Let's hope 300 is large enough to keep it from blocking,
// but doesn't waste tons of memory.
var pendingImageScanLimit = 300

func NewVulnerabilityCache() *VulnerabilityCache {
	return &VulnerabilityCache{
		Pods:              make(map[string]Pod),
		ImageScanResults:  make(map[common.Image]*ImageScanResults),
		imagesToBeScanned: make(chan common.Image, pendingImageScanLimit)}
}

// AddPod should be called when receiving new pods from the
// clustermanager.  It returns true if it hasn't yet seen the pod,
// and false if the pod has already been added.
// It extract the containers and images from the pod,
// adding them into the cache.
func (vc *VulnerabilityCache) AddPod(newPod clustermanager.Pod) bool {
	_, ok := vc.Pods[newPod.UID]
	if ok {
		// TODO should we update the cache?
		// skipping for now
		return false
	}
	log.Infof("about to add pod: %v", newPod)
	containers := []Container{}
	for _, newCont := range newPod.Spec.Containers {
		addedCont := NewContainer(newCont.Image, newCont.Name)
		containers = append(containers, *addedCont)
		_, hasImage := vc.ImageScanResults[newCont.Image]
		if !hasImage {
			addedImage := NewImageScanResults()
			vc.ImageScanResults[newCont.Image] = addedImage
			log.Infof("adding image %s to cache", newCont.Image)
			vc.imagesToBeScanned <- newCont.Image
		} else {
			log.Infof("not adding image %s, already have in cache", newCont.Image)
		}
	}
	log.Infof("done adding containers+images from pod %s:%s", newPod.Namespace, newPod.Name)
	addedPod := NewPod(newPod.Name, string(newPod.UID), newPod.Namespace, containers)
	vc.Pods[addedPod.UID] = *addedPod
	return true
}

func (vc *VulnerabilityCache) AddScanResultsFromProject(project scanner.Project) error {
	vc.mutex.Lock()
	defer vc.mutex.Unlock()
	for _, version := range project.Versions {
		err := vc.addScanResult(version)
		if err != nil {
			return err
		}
	}
	return nil
}

func (vc *VulnerabilityCache) startScanning(image common.Image) error {
	results, ok := vc.ImageScanResults[image]
	if !ok {
		return errors.New(fmt.Sprintf("expected to already have image %s, but did not", image))
	}
	results.ScanStatus = ScanStatusInProgress
	return nil
}

func (vc *VulnerabilityCache) finishedScanning(image common.Image) error {
	results, ok := vc.ImageScanResults[image]
	if !ok {
		return errors.New(fmt.Sprintf("expected to already have image %s, but did not", image))
	}
	results.ScanStatus = ScanStatusComplete
	return nil
}

func (vc *VulnerabilityCache) inProgressScanJobs() []common.Image {
	inProgressImages := []common.Image{}
	for image, results := range vc.ImageScanResults {
		if results.ScanStatus == ScanStatusInProgress {
			inProgressImages = append(inProgressImages, image)
		}
	}
	return inProgressImages
}

func (vc *VulnerabilityCache) addScanResult(version scanner.Version) error {
	image := common.Image(version.VersionName)
	results := ScanResults{
		VulnerabilityCount:   version.RiskProfile.HighRiskVulnerabilityCount(),
		OverallStatus:        version.PolicyStatus.OverallStatus,
		PolicyViolationCount: version.PolicyStatus.ViolationCount()}

	// add scan results into cache
	scanResults, ok := vc.ImageScanResults[image]
	if !ok {
		return errors.New(fmt.Sprintf("expected to already have image %s, but did not", image))
	}

	scanResults.ScanResults = &results
	scanStatus := ScanStatusInProgress
	if version.IsImageScanDone() {
		scanStatus = ScanStatusComplete
	}
	scanResults.ScanStatus = scanStatus

	return nil
}

func (vc *VulnerabilityCache) scanResults(podUID string) (*ScanResults, error) {
	pod, ok := vc.Pods[podUID]
	if !ok {
		return nil, errors.New(fmt.Sprintf("could not find pod of UID %s in cache", podUID))
	}

	overallStatus := ""
	policyViolationCount := 0
	vulnerabilityCount := 0
	for _, container := range pod.Containers {
		imageScanResults, ok := vc.ImageScanResults[container.Image]
		if !ok {
			continue
		}
		if imageScanResults.ScanStatus != ScanStatusComplete {
			continue
		}
		policyViolationCount += imageScanResults.ScanResults.PolicyViolationCount
		vulnerabilityCount += imageScanResults.ScanResults.VulnerabilityCount
		// TODO what's the right way to combine all the 'OverallStatus' values
		//   from the individual image scans?
		if imageScanResults.ScanResults.OverallStatus != "NOT_IN_VIOLATION" {
			overallStatus = imageScanResults.ScanResults.OverallStatus
		}
	}
	return &ScanResults{
		OverallStatus:        overallStatus,
		PolicyViolationCount: policyViolationCount,
		VulnerabilityCount:   vulnerabilityCount,
	}, nil
}
